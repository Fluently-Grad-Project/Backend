<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Voice Chat</title>
  </head>
  <body>
    <h1>Voice Chat Room</h1>
    <button id="start">Start Call</button>
    <button id="stop" disabled>End Call</button>

    <script>
      let socket;
      let audioContext;
      let processor;
      let input;
      let stream;
      let roomId = "room1";

      const token =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo4LCJlbWFpbCI6Im1lbm5hdGFsbGFoYWhtZWQ4OTJAZ21haWwuY29tIiwiZnVsbF9uYW1lIjoibTIgYSIsImlzX3ZlcmlmaWVkIjp0cnVlLCJ0eXBlIjoiQWNjZXNzIiwiZXhwIjoxNzUxNTM5OTg5fQ.xoi3vIpWkav0lmpm6tTicnOS__QSosYMnsm6RIv9VR4";

      const startBtn = document.getElementById("start");
      const stopBtn = document.getElementById("stop");

      startBtn.onclick = async () => {
        socket = new WebSocket(
          `ws://localhost:8000/ws/voice/${roomId}?token=${token}`
        );
        socket.binaryType = "arraybuffer";

        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        input = audioContext.createMediaStreamSource(stream);

        processor = audioContext.createScriptProcessor(2048, 1, 1);
        input.connect(processor);
        processor.connect(audioContext.destination);

        processor.onaudioprocess = (e) => {
          const inputData = e.inputBuffer.getChannelData(0);
          const float32Array = new Float32Array(inputData);
          if (socket.readyState === WebSocket.OPEN) {
            socket.send(float32Array.buffer);
          }
        };

        socket.onmessage = (event) => {
          if (typeof event.data === "string" && event.data === "END_CALL") {
            alert("Call ended by the other user.");
            stopCall();
            return;
          }

          const arrayBuffer = event.data;
          const float32Array = new Float32Array(arrayBuffer);
          const buffer = audioContext.createBuffer(
            1,
            float32Array.length,
            audioContext.sampleRate
          );
          buffer.copyToChannel(float32Array, 0);
          const source = audioContext.createBufferSource();
          source.buffer = buffer;
          source.connect(audioContext.destination);
          source.start();
        };

        socket.onclose = () => {
          stopCall();
        };

        startBtn.disabled = true;
        stopBtn.disabled = false;
      };

      stopBtn.onclick = () => {
        // Send END_CALL as raw bytes
        if (socket && socket.readyState === WebSocket.OPEN) {
          const encoder = new TextEncoder();
          socket.send(encoder.encode("END_CALL"));
        }
        stopCall();
      };

      function stopCall() {
        if (processor) processor.disconnect();
        if (input) input.disconnect();
        if (stream) {
          stream.getTracks().forEach((t) => t.stop());
        }
        if (socket && socket.readyState === WebSocket.OPEN) {
          socket.close();
        }

        startBtn.disabled = false;
        stopBtn.disabled = true;
      }
    </script>
  </body>
</html>
